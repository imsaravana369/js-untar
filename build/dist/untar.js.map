{"version":3,"sources":["untar-worker.js","ProgressivePromise.js","untar.js"],"names":["UntarWorker","define","factory","exports","module","root","untar","this","ProgressivePromise","fn","Promise","Error","progressCallbacks","progressHistory","doProgress","value","i","l","length","push","promise","resolve","reject","origThen","progress","cb","then","onSuccess","onFail","onProgress","call","undefined","workerScriptUri","window","URL","createObjectURL","Blob","global","webkitURL","decoratedFileProps","blob","get","_blob","buffer","getBlobUrl","_blobUrl","readAsString","charCount","byteLength","bufferView","DataView","let","result","offset","chunk","end","Math","min","charCode","getUint8","String","fromCharCode","apply","_string","readAsJSON","arrayBuffer","ArrayBuffer","TypeError","Worker","worker","files","onerror","err","onmessage","message","data","type","console","level","msg","file","terminate","postMessage"],"mappings":"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","file":"untar.js","sourcesContent":["\"use strict\";\n/* globals postMessage: false, DataView: false, self: false, window: false, ArrayBuffer: false, Uint8Array: false */\n\nfunction UntarWorker() {\n\n}\n\nUntarWorker.prototype = {\n\tonmessage: function(msg) {\n\t\ttry {\n\t\t\tif (msg.data.type === \"extract\") {\n\t\t\t\tthis.untarBuffer(msg.data.buffer);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unknown message type: \" + msg.data.type);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.postError(err);\n\t\t}\n\t},\n\n \tpostError: function(err) {\n \t\t//console.info(\"postError(\" + err.message + \")\" + \" \" + JSON.stringify(err));\n\t\tthis.postMessage({ type: \"error\", data: { message: err.message } });\n\t},\n\n\tpostLog: function(level, msg) {\n \t\t//console.info(\"postLog\");\n \t\tthis.postMessage({ type: \"log\", data: { level: level, msg: msg }});\n\t},\n\n\tuntarBuffer: function(arrayBuffer) {\n\t\ttry {\n\t\t\tvar tarFileStream = new UntarFileStream(arrayBuffer);\n\t\t\twhile (tarFileStream.hasNext()) {\n\t\t\t\tvar file = tarFileStream.next();\n\n\t\t\t\tthis.postMessage({ type: \"extract\", data: file }, [file.buffer]);\n\t\t\t}\n\n\t\t\tthis.postMessage({ type: \"complete\" });\n\t\t} catch (err) {\n\t\t\tthis.postError(err);\n\t\t}\n\t},\n\n\tpostMessage: function(msg, transfers) {\n \t\t//console.info(\"postMessage(\" + msg + \", \" + JSON.stringify(transfers) + \")\");\n\t\tself.postMessage(msg, transfers);\n\t}\n};\n\nif (typeof self !== \"undefined\") {\n\t// We're running in a worker thread\n\tvar worker = new UntarWorker();\n\tself.onmessage = function(msg) { worker.onmessage(msg); };\n}\n\n// Source: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\n// Unmarshals an Uint8Array to string.\nfunction decodeUTF8(bytes) {\n    var s = '';\n    var i = 0;\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        if (c > 127) {\n            if (c > 191 && c < 224) {\n                if (i >= bytes.length) throw 'UTF-8 decode: incomplete 2-byte sequence';\n                c = (c & 31) << 6 | bytes[i] & 63;\n            } else if (c > 223 && c < 240) {\n                if (i + 1 >= bytes.length) throw 'UTF-8 decode: incomplete 3-byte sequence';\n                c = (c & 15) << 12 | (bytes[i] & 63) << 6 | bytes[++i] & 63;\n            } else if (c > 239 && c < 248) {\n                if (i+2 >= bytes.length) throw 'UTF-8 decode: incomplete 4-byte sequence';\n                c = (c & 7) << 18 | (bytes[i] & 63) << 12 | (bytes[++i] & 63) << 6 | bytes[++i] & 63;\n            } else throw 'UTF-8 decode: unknown multibyte start 0x' + c.toString(16) + ' at index ' + (i - 1);\n            ++i;\n        }\n\n        if (c <= 0xffff) s += String.fromCharCode(c);\n        else if (c <= 0x10ffff) {\n            c -= 0x10000;\n            s += String.fromCharCode(c >> 10 | 0xd800);\n            s += String.fromCharCode(c & 0x3FF | 0xdc00);\n        } else throw 'UTF-8 decode: code point 0x' + c.toString(16) + ' exceeds UTF-16 reach';\n    }\n    return s;\n}\n\nfunction PaxHeader(fields) {\n    this._fields = fields;\n}\n\nPaxHeader.parse = function(buffer) {\n    // https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.bpxa500/paxex.htm\n    // An extended header shall consist of one or more records, each constructed as follows:\n    // \"%d %s=%s\\n\", <length>, <keyword>, <value>\n\n    // The extended header records shall be encoded according to the ISO/IEC10646-1:2000 standard (UTF-8).\n    // The <length> field, <blank>, equals sign, and <newline> shown shall be limited to the portable character set, as\n    // encoded in UTF-8. The <keyword> and <value> fields can be any UTF-8 characters. The <length> field shall be the\n    // decimal length of the extended header record in octets, including the trailing <newline>.\n\n    var bytes = new Uint8Array(buffer);\n    var fields = [];\n\n    while (bytes.length > 0) {\n        // Decode bytes up to the first space character; that is the total field length\n        var fieldLength = parseInt(decodeUTF8(bytes.subarray(0, bytes.indexOf(0x20))));\n        var fieldText = decodeUTF8(bytes.subarray(0, fieldLength));\n        var fieldMatch = fieldText.match(/^\\d+ ([^=]+)=(.*)\\n$/);\n\n        if (fieldMatch === null) {\n            throw new Error(\"Invalid PAX header data format.\");\n        }\n\n        var fieldName = fieldMatch[1];\n        var fieldValue = fieldMatch[2];\n\n        if (fieldValue.length === 0) {\n            fieldValue = null;\n        } else if (fieldValue.match(/^\\d+$/) !== null) {\n            // If it's a integer field, parse it as int\n            fieldValue = parseInt(fieldValue);\n        }\n        // Don't parse float values since precision is lost\n\n\n        var field = {\n            name: fieldName,\n            value: fieldValue\n        };\n\n        fields.push(field);\n\n        bytes = bytes.subarray(fieldLength); // Cut off the parsed field data\n    }\n\n    return new PaxHeader(fields);\n};\n\nPaxHeader.prototype = {\n    applyHeader: function(file) {\n        // Apply fields to the file\n        // If a field is of value null, it should be deleted from the file\n        // https://www.mkssoftware.com/docs/man4/pax.4.asp\n\n        this._fields.forEach(function(field) {\n            var fieldName = field.name;\n            var fieldValue = field.value;\n\n            if (fieldName === \"path\") {\n                // This overrides the name and prefix fields in the following header block.\n                fieldName = \"name\";\n\n                if (file.prefix !== undefined) {\n                    delete file.prefix;\n                }\n            } else if (fieldName === \"linkpath\") {\n                // This overrides the linkname field in the following header block.\n                fieldName = \"linkname\";\n            }\n\n            if (fieldValue === null) {\n                delete file[fieldName];\n            } else {\n                file[fieldName] = fieldValue;\n            }\n        });\n    }\n};\n\nfunction TarFile() {\n\n}\n\nfunction UntarStream(arrayBuffer) {\n\tthis._bufferView = new DataView(arrayBuffer);\n\tthis._position = 0;\n}\n\nUntarStream.prototype = {\n\treadString: function(charCount) {\n\t\t//console.log(\"readString: position \" + this.position() + \", \" + charCount + \" chars\");\n\t\tvar charSize = 1;\n\t\tvar byteCount = charCount * charSize;\n\n\t\tvar charCodes = [];\n\n\t\tfor (var i = 0; i < charCount; ++i) {\n\t\t\tvar charCode = this._bufferView.getUint8(this.position() + (i * charSize), true);\n\t\t\tif (charCode !== 0) {\n\t\t\t\tcharCodes.push(charCode);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.seek(byteCount);\n\n\t\treturn String.fromCharCode.apply(null, charCodes);\n\t},\n\n\treadBuffer: function(byteCount) {\n\t\tvar buf;\n\n\t\tif (typeof ArrayBuffer.prototype.slice === \"function\") {\n\t\t\tbuf = this._bufferView.buffer.slice(this.position(), this.position() + byteCount);\n\t\t} else {\n\t\t\tbuf = new ArrayBuffer(byteCount);\n\t\t\tvar target = new Uint8Array(buf);\n\t\t\tvar src = new Uint8Array(this._bufferView.buffer, this.position(), byteCount);\n\t\t\ttarget.set(src);\n\t\t}\n\n\t\tthis.seek(byteCount);\n\t\treturn buf;\n\t},\n\n\tseek: function(byteCount) {\n\t\tthis._position += byteCount;\n\t},\n\n\tpeekUint32: function() {\n\t\treturn this._bufferView.getUint32(this.position(), true);\n\t},\n\n\tposition: function(newpos) {\n\t\tif (newpos === undefined) {\n\t\t\treturn this._position;\n\t\t} else {\n\t\t\tthis._position = newpos;\n\t\t}\n\t},\n\n\tsize: function() {\n\t\treturn this._bufferView.byteLength;\n\t}\n};\n\nfunction UntarFileStream(arrayBuffer) {\n\tthis._stream = new UntarStream(arrayBuffer);\n\tthis._globalPaxHeader = null;\n}\n\nUntarFileStream.prototype = {\n\thasNext: function() {\n\t\t// A tar file ends with 4 zero bytes\n\t\treturn this._stream.position() + 4 < this._stream.size() && this._stream.peekUint32() !== 0;\n\t},\n\n\tnext: function() {\n\t\treturn this._readNextFile();\n\t},\n\n\t_readNextFile: function() {\n\t\tvar stream = this._stream;\n\t\tvar file = new TarFile();\n\t\tvar isHeaderFile = false;\n\t\tvar paxHeader = null;\n\n\t\tvar headerBeginPos = stream.position();\n\t\tvar dataBeginPos = headerBeginPos + 512;\n\n\t\t// Read header\n\t\tfile.name = stream.readString(100);\n\t\tfile.mode = stream.readString(8);\n\t\tfile.uid = parseInt(stream.readString(8));\n\t\tfile.gid = parseInt(stream.readString(8));\n\t\tfile.size = parseInt(stream.readString(12), 8);\n\t\tfile.mtime = parseInt(stream.readString(12), 8);\n\t\tfile.checksum = parseInt(stream.readString(8));\n\t\tfile.type = stream.readString(1);\n\t\tfile.linkname = stream.readString(100);\n\t\tfile.ustarFormat = stream.readString(6);\n\n\t\tif (file.ustarFormat.indexOf(\"ustar\") > -1) {\n\t\t\tfile.version = stream.readString(2);\n\t\t\tfile.uname = stream.readString(32);\n\t\t\tfile.gname = stream.readString(32);\n\t\t\tfile.devmajor = parseInt(stream.readString(8));\n\t\t\tfile.devminor = parseInt(stream.readString(8));\n\t\t\tfile.namePrefix = stream.readString(155);\n\n\t\t\tif (file.namePrefix.length > 0) {\n                            file.name = file.namePrefix + \"/\" + file.name;\n\t\t\t}\n\t\t}\n\n\t\tstream.position(dataBeginPos);\n\n        // Derived from https://www.mkssoftware.com/docs/man4/pax.4.asp\n        // and https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.bpxa500/pxarchfm.htm\n        switch (file.type) {\n            case \"0\": // Normal file is either \"0\" or \"\\0\".\n            case \"\": // In case of \"\\0\", readString returns an empty string, that is \"\".\n                file.buffer = stream.readBuffer(file.size);\n                break;\n            case \"1\": // Link to another file already archived\n                // TODO Should we do anything with these?\n                break;\n            case \"2\": // Symbolic link\n                // TODO Should we do anything with these?\n                break;\n            case \"3\": // Character special device (what does this mean??)\n                break;\n            case \"4\": // Block special device\n                break;\n            case \"5\": // Directory\n                break;\n            case \"6\": // FIFO special file\n                break;\n            case \"7\": // Reserved\n                break;\n            case \"g\": // Global PAX header\n                isHeaderFile = true;\n                this._globalPaxHeader = PaxHeader.parse(stream.readBuffer(file.size));\n                break;\n            case \"x\": // PAX header\n                isHeaderFile = true;\n                paxHeader = PaxHeader.parse(stream.readBuffer(file.size));\n                break;\n            default: // Unknown file type\n                break;\n        }\n\n\t\tif (file.buffer === undefined) {\n\t\t\tfile.buffer = new ArrayBuffer(0);\n\t\t}\n\n\t\tvar dataEndPos = dataBeginPos + file.size;\n\n\t\t// File data is padded to reach a 512 byte boundary; skip the padded bytes too.\n\t\tif (file.size % 512 !== 0) {\n\t\t\tdataEndPos += 512 - (file.size % 512);\n\t\t}\n\n\t\tstream.position(dataEndPos);\n\n\t\tif (isHeaderFile) {\n\t\t    file = this._readNextFile();\n        }\n\n        if (this._globalPaxHeader !== null) {\n\t\t    this._globalPaxHeader.applyHeader(file);\n        }\n\n        if (paxHeader !== null) {\n\t\t    paxHeader.applyHeader(file);\n        }\n\n\t\treturn file;\n\t}\n};\n","/* globals window: false, Promise: false */\n\n/**\nReturns a Promise decorated with a progress() event.\n*/\nfunction ProgressivePromise(fn) {\n\tif (typeof Promise !== \"function\") {\n\t\tthrow new Error(\"Promise implementation not available in this environment.\");\n\t}\n\n\tvar progressCallbacks = [];\n\tvar progressHistory = [];\n\n\tfunction doProgress(value) {\n\t\tfor (var i = 0, l = progressCallbacks.length; i < l; ++i) {\n\t\t\tprogressCallbacks[i](value);\n\t\t}\n\n\t\tprogressHistory.push(value);\n\t}\n\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tfn(resolve, reject, doProgress);\n\t});\n\n\tpromise.progress = function(cb) {\n\t\tif (typeof cb !== \"function\") {\n\t\t\tthrow new Error(\"cb is not a function.\");\n\t\t}\n\n\t\t// Report the previous progress history\n\t\tfor (var i = 0, l = progressHistory.length; i < l; ++i) {\n\t\t\tcb(progressHistory[i]);\n\t\t}\n\n\t\tprogressCallbacks.push(cb);\n\t\treturn promise;\n\t};\n\n\tvar origThen = promise.then;\n\n\tpromise.then = function(onSuccess, onFail, onProgress) {\n\t\torigThen.call(promise, onSuccess, onFail);\n\n\t\tif (onProgress !== undefined) {\n\t\t\tpromise.progress(onProgress);\n\t\t}\n\n\t\treturn promise;\n\t};\n\n\treturn promise;\n}",";(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.untar = factory();\n  }\n}(this, function() {\n\"use strict\";\n\nworkerScriptUri = (window||this).URL.createObjectURL(new Blob([\"function UntarWorker(){}var worker;function decodeUTF8(e){for(var r=\\\"\\\",t=0;t<e.length;){var a=e[t++];if(127<a){if(191<a&&a<224){if(t>=e.length)throw\\\"UTF-8 decode: incomplete 2-byte sequence\\\";a=(31&a)<<6|63&e[t]}else if(223<a&&a<240){if(t+1>=e.length)throw\\\"UTF-8 decode: incomplete 3-byte sequence\\\";a=(15&a)<<12|(63&e[t])<<6|63&e[++t]}else{if(!(239<a&&a<248))throw\\\"UTF-8 decode: unknown multibyte start 0x\\\"+a.toString(16)+\\\" at index \\\"+(t-1);if(t+2>=e.length)throw\\\"UTF-8 decode: incomplete 4-byte sequence\\\";a=(7&a)<<18|(63&e[t])<<12|(63&e[++t])<<6|63&e[++t]}++t}if(a<=65535)r+=String.fromCharCode(a);else{if(!(a<=1114111))throw\\\"UTF-8 decode: code point 0x\\\"+a.toString(16)+\\\" exceeds UTF-16 reach\\\";a-=65536,r=(r+=String.fromCharCode(a>>10|55296))+String.fromCharCode(1023&a|56320)}}return r}function PaxHeader(e){this._fields=e}function TarFile(){}function UntarStream(e){this._bufferView=new DataView(e),this._position=0}function UntarFileStream(e){this._stream=new UntarStream(e),this._globalPaxHeader=null}UntarWorker.prototype={onmessage:function(e){try{if(\\\"extract\\\"!==e.data.type)throw new Error(\\\"Unknown message type: \\\"+e.data.type);this.untarBuffer(e.data.buffer)}catch(e){this.postError(e)}},postError:function(e){this.postMessage({type:\\\"error\\\",data:{message:e.message}})},postLog:function(e,r){this.postMessage({type:\\\"log\\\",data:{level:e,msg:r}})},untarBuffer:function(e){try{for(var r=new UntarFileStream(e);r.hasNext();){var t=r.next();this.postMessage({type:\\\"extract\\\",data:t},[t.buffer])}this.postMessage({type:\\\"complete\\\"})}catch(e){this.postError(e)}},postMessage:function(e,r){self.postMessage(e,r)}},\\\"undefined\\\"!=typeof self&&(worker=new UntarWorker,self.onmessage=function(e){worker.onmessage(e)}),PaxHeader.parse=function(e){for(var r=new Uint8Array(e),t=[];0<r.length;){var a=parseInt(decodeUTF8(r.subarray(0,r.indexOf(32)))),n=decodeUTF8(r.subarray(0,a)).match(/^\\\\d+ ([^=]+)=(.*)\\\\n$/);if(null===n)throw new Error(\\\"Invalid PAX header data format.\\\");var i=n[1],n=n[2],i=(0===n.length?n=null:null!==n.match(/^\\\\d+$/)&&(n=parseInt(n)),{name:i,value:n});t.push(i),r=r.subarray(a)}return new PaxHeader(t)},PaxHeader.prototype={applyHeader:function(t){this._fields.forEach(function(e){var r=e.name,e=e.value;\\\"path\\\"===r?(r=\\\"name\\\",void 0!==t.prefix&&delete t.prefix):\\\"linkpath\\\"===r&&(r=\\\"linkname\\\"),null===e?delete t[r]:t[r]=e})}},UntarStream.prototype={readString:function(e){for(var r=+e,t=[],a=0;a<e;++a){var n=this._bufferView.getUint8(this.position()+ +a,!0);if(0===n)break;t.push(n)}return this.seek(r),String.fromCharCode.apply(null,t)},readBuffer:function(e){var r,t,a;return\\\"function\\\"==typeof ArrayBuffer.prototype.slice?r=this._bufferView.buffer.slice(this.position(),this.position()+e):(r=new ArrayBuffer(e),t=new Uint8Array(r),a=new Uint8Array(this._bufferView.buffer,this.position(),e),t.set(a)),this.seek(e),r},seek:function(e){this._position+=e},peekUint32:function(){return this._bufferView.getUint32(this.position(),!0)},position:function(e){if(void 0===e)return this._position;this._position=e},size:function(){return this._bufferView.byteLength}},UntarFileStream.prototype={hasNext:function(){return this._stream.position()+4<this._stream.size()&&0!==this._stream.peekUint32()},next:function(){return this._readNextFile()},_readNextFile:function(){var e=this._stream,r=new TarFile,t=!1,a=null,n=e.position()+512;switch(r.name=e.readString(100),r.mode=e.readString(8),r.uid=parseInt(e.readString(8)),r.gid=parseInt(e.readString(8)),r.size=parseInt(e.readString(12),8),r.mtime=parseInt(e.readString(12),8),r.checksum=parseInt(e.readString(8)),r.type=e.readString(1),r.linkname=e.readString(100),r.ustarFormat=e.readString(6),-1<r.ustarFormat.indexOf(\\\"ustar\\\")&&(r.version=e.readString(2),r.uname=e.readString(32),r.gname=e.readString(32),r.devmajor=parseInt(e.readString(8)),r.devminor=parseInt(e.readString(8)),r.namePrefix=e.readString(155),0<r.namePrefix.length)&&(r.name=r.namePrefix+\\\"/\\\"+r.name),e.position(n),r.type){case\\\"0\\\":case\\\"\\\":r.buffer=e.readBuffer(r.size);break;case\\\"1\\\":case\\\"2\\\":case\\\"3\\\":case\\\"4\\\":case\\\"5\\\":case\\\"6\\\":case\\\"7\\\":break;case\\\"g\\\":t=!0,this._globalPaxHeader=PaxHeader.parse(e.readBuffer(r.size));break;case\\\"x\\\":t=!0,a=PaxHeader.parse(e.readBuffer(r.size))}void 0===r.buffer&&(r.buffer=new ArrayBuffer(0));n+=r.size;return r.size%512!=0&&(n+=512-r.size%512),e.position(n),t&&(r=this._readNextFile()),null!==this._globalPaxHeader&&this._globalPaxHeader.applyHeader(r),null!==a&&a.applyHeader(r),r}};\"]));\n/* globals window: false, Promise: false */\n\n/**\nReturns a Promise decorated with a progress() event.\n*/\nfunction ProgressivePromise(fn) {\n\tif (typeof Promise !== \"function\") {\n\t\tthrow new Error(\"Promise implementation not available in this environment.\");\n\t}\n\n\tvar progressCallbacks = [];\n\tvar progressHistory = [];\n\n\tfunction doProgress(value) {\n\t\tfor (var i = 0, l = progressCallbacks.length; i < l; ++i) {\n\t\t\tprogressCallbacks[i](value);\n\t\t}\n\n\t\tprogressHistory.push(value);\n\t}\n\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tfn(resolve, reject, doProgress);\n\t});\n\n\tpromise.progress = function(cb) {\n\t\tif (typeof cb !== \"function\") {\n\t\t\tthrow new Error(\"cb is not a function.\");\n\t\t}\n\n\t\t// Report the previous progress history\n\t\tfor (var i = 0, l = progressHistory.length; i < l; ++i) {\n\t\t\tcb(progressHistory[i]);\n\t\t}\n\n\t\tprogressCallbacks.push(cb);\n\t\treturn promise;\n\t};\n\n\tvar origThen = promise.then;\n\n\tpromise.then = function(onSuccess, onFail, onProgress) {\n\t\torigThen.call(promise, onSuccess, onFail);\n\n\t\tif (onProgress !== undefined) {\n\t\t\tpromise.progress(onProgress);\n\t\t}\n\n\t\treturn promise;\n\t};\n\n\treturn promise;\n}\n/* globals Blob: false, Promise: false, console: false, Worker: false, ProgressivePromise: false */\n\nvar workerScriptUri; // Included at compile time\n\nvar global = window || this;\n\nvar URL = global.URL || global.webkitURL;\n\n/**\nReturns a ProgressivePromise.\n*/\nfunction untar(arrayBuffer) {\n\tif (!(arrayBuffer instanceof ArrayBuffer)) {\n\t\tthrow new TypeError(\"arrayBuffer is not an instance of ArrayBuffer.\");\n\t}\n\n\tif (!global.Worker) {\n\t\tthrow new Error(\"Worker implementation is not available in this environment.\");\n\t}\n\n\treturn new ProgressivePromise(function(resolve, reject, progress) {\n\t\tvar worker = new Worker(workerScriptUri);\n\n\t\tvar files = [];\n\n\t\tworker.onerror = function(err) {\n\t\t\treject(err);\n\t\t};\n\n\t\tworker.onmessage = function(message) {\n\t\t\tmessage = message.data;\n\n\t\t\tswitch (message.type) {\n\t\t\t\tcase \"log\":\n\t\t\t\t\tconsole[message.data.level](\"Worker: \" + message.data.msg);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"extract\":\n\t\t\t\t\tvar file = decorateExtractedFile(message.data);\n\t\t\t\t\tfiles.push(file);\n\t\t\t\t\tprogress(file);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"complete\":\n\t\t\t\t\tworker.terminate();\n\t\t\t\t\tresolve(files);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\t//console.log(\"error message\");\n\t\t\t\t\tworker.terminate();\n\t\t\t\t\treject(new Error(message.data.message));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tworker.terminate();\n\t\t\t\t\treject(new Error(\"Unknown message from worker: \" + message.type));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\t//console.info(\"Sending arraybuffer to worker for extraction.\");\n\t\tworker.postMessage({ type: \"extract\", buffer: arrayBuffer }, [arrayBuffer]);\n\t});\n}\n\nvar decoratedFileProps = {\n\tblob: {\n\t\tget: function() {\n\t\t\treturn this._blob || (this._blob = new Blob([this.buffer]));\n\t\t}\n\t},\n\tgetBlobUrl: {\n\t\tvalue: function() {\n\t\t\treturn this._blobUrl || (this._blobUrl = URL.createObjectURL(this.blob));\n\t\t}\n\t},\n\treadAsString: {\n\t\tvalue: function () {\n\t\t\tconst buffer = this.buffer;\n\t\t\tconst charCount = buffer.byteLength;\n\t\t\tconst bufferView = new DataView(buffer);\n\n\t\t\tconst chunkSize = 65536; // Process in chunks of 64KB\n\t\t\tlet result = '';\n\n\t\t\tfor (let offset = 0; offset < charCount; offset +=chunkSize) { \n\t\t\t\tconst chunk=[];\n\t\t\t\tconst end=Math.min(offset + chunkSize, charCount);\n\t\t\t\tfor (let i=offset; i < end; ++i) {\n\t\t\t\t\tconst charCode=bufferView.getUint8(i);\n\t\t\t\t\tchunk.push(charCode); \n\t\t\t\t}\n\t\t\t\tresult +=String.fromCharCode.apply(null, chunk); \n\t\t\t} \n\t\t\treturn (this._string=result); \n\t\t}, \n\t},\n\treadAsJSON: {\n\t\tvalue: function() {\n\t\t\treturn JSON.parse(this.readAsString());\n\t\t}\n\t}\n};\n\nfunction decorateExtractedFile(file) {\n\tObject.defineProperties(file, decoratedFileProps);\n\treturn file;\n}\n\nreturn untar;\n}));\n"]}